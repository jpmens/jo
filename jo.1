'\" t
.\" Automatically generated by Pandoc 3.7.0.2
.\"
.TH "JO" "1" "" "User Manuals"
.SH NAME
jo \- JSON output from a shell
.SH SYNOPSIS
jo [\-p] [\-a] [\-B] [\-D] [\-e] [\-n] [\-v] [\-V] [\-d keydelim] [\-f
file] [\(en] [ [\-s|\-n|\-b] word \&...]
.SH DESCRIPTION
\f[I]jo\f[R] creates a JSON string on \f[I]stdout\f[R] from
\f[I]word\f[R]s given it as arguments or read from \f[I]stdin\f[R].
If \f[CR]\-f\f[R] is specified, \f[I]jo\f[R] first loads the contents of
\f[I]file\f[R] as a JSON object or array, then modifies it with
subsequent \f[I]word\f[R]s before printing the final JSON string to
\f[I]stdout\f[R].
\f[I]file\f[R] may be specified as \f[CR]\-\f[R] to read from
\f[I]jo\f[R]\(cqs standard input; this takes precedence over reading
\f[I]word\f[R]s from \f[I]stdin\f[R].
.PP
Without option \f[CR]\-a\f[R] it generates an object whereby each
\f[I]word\f[R] is a \f[CR]key=value\f[R] (or \f[CR]key\(atvalue\f[R])
pair with \f[I]key\f[R] being the JSON object element and
\f[I]value\f[R] its value.
\f[I]jo\f[R] attempts to guess the type of \f[I]value\f[R] in order to
create number (using \f[I]strtod(3)\f[R]), string, or null values in
JSON.
.PP
A missing or empty \f[I]value\f[R] normally results in an element whose
value is \f[CR]null\f[R].
If \f[CR]\-n\f[R] is specified, this element is not created.
.PP
\f[I]jo\f[R] normally treats \f[I]key\f[R] as a literal string value.
If the \f[CR]\-d\f[R] option is specified, \f[I]key\f[R] will be
interpreted as an \f[I]object path\f[R], whose individual components are
separated by the first character of \f[I]keydelim\f[R].
.PP
\f[I]jo\f[R] first tries to parse \f[I]value\f[R] as a JSON value.
If that fails, it treats \f[I]value\f[R] as a literal string value,
unless it begins with one of the following characters:
.PP
.TS
tab(@);
l l.
T{
value
T}@T{
action
T}
_
T{
\(atfile
T}@T{
substitute the contents of \f[I]file\f[R] as\-is
T}
T{
%file
T}@T{
substitute the contents of \f[I]file\f[R] in base64\-encoded form
T}
T{
:file
T}@T{
interpret the contents of \f[I]file\f[R] as JSON, and substitute the
result
T}
.TE
.PP
Escape the special character with a backslash to prevent this
interpretation.
.PP
\f[I]jo\f[R] treats \f[CR]key\(atvalue\f[R] specifically as boolean JSON
elements: if the value begins with \f[CR]T\f[R], \f[CR]t\f[R], or the
numeric value is greater than zero, the result is \f[CR]true\f[R], else
\f[CR]false\f[R].
.PP
\f[I]jo\f[R] creates an array instead of an object when \f[CR]\-a\f[R]
is specified.
.PP
When the \f[CR]:=\f[R] operator is used in a \f[I]word\f[R], the name to
the right of \f[CR]:=\f[R] is a file containing JSON which is parsed and
assigned to the key left of the operator.
The file may be specified as \f[CR]\-\f[R] to read from
\f[I]jo\f[R]\(cqs standard input.
.SH TYPE COERCION
\f[I]jo\f[R]\(cqs type guesses can be overridden on a per\-word basis by
prefixing \f[I]word\f[R] with \f[CR]\-s\f[R] for \f[I]string\f[R],
\f[CR]\-n\f[R] for \f[I]number\f[R], or \f[CR]\-b\f[R] for
\f[I]boolean\f[R].
The list of \f[I]word\f[R]s \f[I]must\f[R] be prefixed with
\f[CR]\-\-\f[R], to indicate to \f[I]jo\f[R] that there are no more
global options.
.PP
Type coercion works as follows:
.PP
.TS
tab(@);
l l l l l.
T{
word
T}@T{
\-s
T}@T{
\-n
T}@T{
\-b
T}@T{
default
T}
_
T{
a=
T}@T{
\(lqa\(rq:\(lq\(rq
T}@T{
\(lqa\(rq:0
T}@T{
\(lqa\(rq:false
T}@T{
\(lqa\(rq:null
T}
T{
a=string
T}@T{
\(lqa\(rq:\(lqstring\(rq
T}@T{
\(lqa\(rq:6
T}@T{
\(lqa\(rq:true
T}@T{
\(lqa\(rq:\(lqstring\(rq
T}
T{
a=\(dqquoted\(dq
T}@T{
\(lqa\(rq:\(lq\(dqquoted\(dq\(rq
T}@T{
\(lqa\(rq:8
T}@T{
\(lqa\(rq:true
T}@T{
\(lqa\(rq:\(lq\(dqquoted\(dq\(rq
T}
T{
a=12345
T}@T{
\(lqa\(rq:\(lq12345\(rq
T}@T{
\(lqa\(rq:12345
T}@T{
\(lqa\(rq:true
T}@T{
\(lqa\(rq:12345
T}
T{
a=true
T}@T{
\(lqa\(rq:\(lqtrue\(rq
T}@T{
\(lqa\(rq:1
T}@T{
\(lqa\(rq:true
T}@T{
\(lqa\(rq:true
T}
T{
a=false
T}@T{
\(lqa\(rq:\(lqfalse\(rq
T}@T{
\(lqa\(rq:0
T}@T{
\(lqa\(rq:false
T}@T{
\(lqa\(rq:false
T}
T{
a=null
T}@T{
\(lqa\(rq:\(lq\(rq
T}@T{
\(lqa\(rq:0
T}@T{
\(lqa\(rq:false
T}@T{
\(lqa\(rq:null
T}
.TE
.PP
Coercing a non\-number string to number outputs the \f[I]length\f[R] of
the string.
.PP
Coercing a non\-boolean string to boolean outputs \f[CR]false\f[R] if
the string is empty, \f[CR]true\f[R] otherwise.
.PP
Type coercion only applies to \f[CR]key=value\f[R] words, and individual
words in a \f[CR]\-a\f[R] array.
Coercing other words has no effect.
.SH EXAMPLES
Create an object.
Note how the incorrectly\-formatted float value becomes a string:
.IP
.EX
$ jo tst=1457081292 lat=12.3456 cc=FR badfloat=3.14159.26 name=\(dqJP Mens\(dq nada= coffee\(atT
{\(dqtst\(dq:1457081292,\(dqlat\(dq:12.3456,\(dqcc\(dq:\(dqFR\(dq,\(dqbadfloat\(dq:\(dq3.14159.26\(dq,\(dqname\(dq:\(dqJP Mens\(dq,\(dqnada\(dq:null,\(dqcoffee\(dq:true}
.EE
.PP
Pretty\-print an array with a list of files in the current directory:
.IP
.EX
$ jo \-p \-a *
[
 \(dqMakefile\(dq,
 \(dqREADME.md\(dq,
 \(dqjo.1\(dq,
 \(dqjo.c\(dq,
 \(dqjo.pandoc\(dq,
 \(dqjson.c\(dq,
 \(dqjson.h\(dq
]
.EE
.PP
Create objects within objects.
Beware spaces in strings; it\(cqs generally a good idea to double\-quote
nested \f[I]jo\f[R] invocations:
.IP
.EX
$ jo \-p name=JP object=\(dq$(jo fruit=Blood\(rs Orange hungry\(at0 point=\(dq$(jo x=10 y=20 list=\(dq$(jo \-a 1 2 3 4 5)\(dq)\(dq number=17)\(dq sunday\(at0
{
 \(dqname\(dq: \(dqJP\(dq,
 \(dqobject\(dq: {
  \(dqfruit\(dq: \(dqBlood Orange\(dq,
  \(dqhungry\(dq: false,
  \(dqpoint\(dq: {
   \(dqx\(dq: 10,
   \(dqy\(dq: 20,
   \(dqlist\(dq: [
    1,
    2,
    3,
    4,
    5
   ]
  },
  \(dqnumber\(dq: 17
 },
 \(dqsunday\(dq: false
}
.EE
.PP
Booleans as strings or as boolean (pay particular attention to
\f[I]switch\f[R]; the \f[CR]\-B\f[R] option disables the default
detection of the \(lq\f[CR]true\f[R]\(rq, \(lq\f[CR]false\f[R]\(rq, and
\(lq\f[CR]null\f[R]\(rq strings):
.IP
.EX
$ jo switch=true morning\(at0
{\(dqswitch\(dq:true,\(dqmorning\(dq:false}

$ jo \-B switch=true morning\(at0
{\(dqswitch\(dq:\(dqtrue\(dq,\(dqmorning\(dq:false}
.EE
.PP
Elements (objects and arrays) can be nested.
The following example nests an array called \f[I]point\f[R] and an
object named \f[I]geo\f[R]:
.IP
.EX
$ jo \-p name=Jane point[]=1 point[]=2 geo[lat]=10 geo[lon]=20
{
   \(dqname\(dq: \(dqJane\(dq,
   \(dqpoint\(dq: [
      1,
      2
   ],
   \(dqgeo\(dq: {
      \(dqlat\(dq: 10,
      \(dqlon\(dq: 20
   }
}
.EE
.PP
The same example, using object paths:
.IP
.EX
$ jo \-p \-d. name=Jane point[]=1 point[]=2 geo.lat=10 geo.lon=20
{
   \(dqname\(dq: \(dqJane\(dq,
   \(dqpoint\(dq: [
      1,
      2
   ],
   \(dqgeo\(dq: {
      \(dqlat\(dq: 10,
      \(dqlon\(dq: 20
   }
}
.EE
.PP
Without \f[CR]\-d\f[R], a different object is generated:
.IP
.EX
$ jo \-p name=Jane point[]=1 point[]=2 geo.lat=10 geo.lon=20
{
   \(dqname\(dq: \(dqJane\(dq,
   \(dqpoint\(dq: [
      1,
      2
   ],
   \(dqgeo.lat\(dq: 10,
   \(dqgeo.lon\(dq: 20
}
.EE
.PP
Create empty objects or arrays, intentionally or potentially:
.IP
.EX
$ jo < /dev/null
{}

$ MY_ARRAY=(a=1 b=2)
$ jo \-a \(dq${MY_ARRAY[\(at]}\(dq < /dev/null
[\(dqa=1\(dq,\(dqb=2\(dq]
.EE
.PP
Type coercion:
.IP
.EX
$ jo \-p \-\- \-s a=true b=true \-s c=123 d=123 \-b e=\(dq1\(dq \-b f=\(dqtrue\(dq \-n g=\(dqThis is a test\(dq \-b h=\(dqThis is a test\(dq
{
   \(dqa\(dq: \(dqtrue\(dq,
   \(dqb\(dq: true,
   \(dqc\(dq: \(dq123\(dq,
   \(dqd\(dq: 123,
   \(dqe\(dq: true,
   \(dqf\(dq: true,
   \(dqg\(dq: 14,
   \(dqh\(dq: true
}

$ jo \-a \-\- \-s 123 \-n \(dqThis is a test\(dq \-b C_Rocks 456
[\(dq123\(dq,14,true,456]
.EE
.PP
Read element values from files: a value which starts with
\f[CR]\(at\f[R] is read in plain whereas if it begins with a
\f[CR]%\f[R] it will be base64\-encoded and if it starts with
\f[CR]:\f[R] the contents are interpreted as JSON:
.IP
.EX
$ jo program=jo authors=\(atAUTHORS
{\(dqprogram\(dq:\(dqjo\(dq,\(dqauthors\(dq:\(dqJan\-Piet Mens <jpmens\(atgmail.com>\(dq}

$ jo filename=AUTHORS content=%AUTHORS
{\(dqfilename\(dq:\(dqAUTHORS\(dq,\(dqcontent\(dq:\(dqSmFuLVBpZXQgTWVucyA8anBtZW5zQGdtYWlsLmNvbT4K\(dq}

$ jo nested=:nested.json
{\(dqnested\(dq:{\(dqfield1\(dq:123,\(dqfield2\(dq:\(dqabc\(dq}}
.EE
.PP
These characters can be escaped to avoid interpretation:
.IP
.EX
$ jo name=\(dqJP Mens\(dq twitter=\(aq\(rs\(atjpmens\(aq
{\(dqname\(dq:\(dqJP Mens\(dq,\(dqtwitter\(dq:\(dq\(atjpmens\(dq}

$ jo char=\(dq \(dq URIescape=\(rs\(rs%20
{\(dqchar\(dq:\(dq \(dq,\(dqURIescape\(dq:\(dq%20\(dq}

$ jo action=\(dqsplit window\(dq vimcmd=\(dq\(rs:split\(dq
{\(dqaction\(dq:\(dqsplit window\(dq,\(dqvimcmd\(dq:\(dq:split\(dq}
.EE
.PP
Read element values from a file in order to overcome ARG_MAX limits
during object assignment:
.IP
.EX
$ ls | jo \-a > child.json
$ jo files:=child.json
{\(dqfiles\(dq:[\(dqAUTHORS\(dq,\(dqCOPYING\(dq,\(dqChangeLog\(dq ....

$ ls *.c | jo \-a > source.json; ls *.h | jo \-a > headers.json
$ jo \-a :source.json :headers.json
[[\(dqbase64.c\(dq,\(dqjo.c\(dq,\(dqjson.c\(dq],[\(dqbase64.h\(dq,\(dqjson.h\(dq]]
.EE
.PP
Add elements to existing JSON:
.IP
.EX
$ jo \-f source.json 1 | jo \-f \- 2 3
[\(dqbase64.c\(dq,\(dqjo.c\(dq,\(dqjson.c\(dq,1,2,3]

$ curl \-s \(aqhttps://noembed.com/embed?url=https://www.youtube.com/watch?v=dQw4w9WgXcQ\(aq | jo \-f \- status=Rickrolled
{ ...., \(dqtype\(dq:\(dqvideo\(dq,\(dqauthor_url\(dq:\(dqhttps://www.youtube.com/user/RickAstleyVEVO\(dq,\(dqstatus\(dq:\(dqRickrolled\(dq}
.EE
.PP
Deduplicate object keys (\f[I]jo\f[R] appends duplicate object keys by
default):
.IP
.EX
$ jo a=1 b=2 a=3
{\(dqa\(dq:1,\(dqb\(dq:2,\(dqa\(dq:3}
$ jo \-D a=1 b=2 a=3
{\(dqa\(dq:3,\(dqb\(dq:2}
.EE
.SH OPTIONS
\f[I]jo\f[R] understands the following global options.
.TP
\-a
Interpret the list of \f[I]words\f[R] as array values and produce an
array instead of an object.
.TP
\-B
By default, \f[I]jo\f[R] interprets the strings \(lq\f[CR]true\f[R]\(rq
and \(lq\f[CR]false\f[R]\(rq as boolean elements \f[CR]true\f[R] and
\f[CR]false\f[R] respectively, and \(lq\f[CR]null\f[R]\(rq as
\f[CR]null\f[R].
Disable with this option.
.TP
\-D
Deduplicate object keys.
.TP
\-e
Ignore empty stdin (i.e.\ don\(cqt produce a diagnostic error when
\f[I]stdin\f[R] is empty)
.TP
\-n
Do not add keys with empty values.
.TP
\-p
Pretty\-print the JSON string on output instead of the terse one\-line
output it prints by default.
.TP
\-v
Show version and exit.
.TP
\-V
Show version as a JSON object and exit.
.SH BUGS
Probably.
.PP
If a value given to \f[I]jo\f[R] expands to empty in the shell, then
\f[I]jo\f[R] produces a \f[CR]null\f[R] in object mode, and might appear
to hang in array mode; it is not hanging, rather it\(cqs reading
\f[I]stdin\f[R].
This is not a bug.
.PP
Numeric values are converted to numbers which can produce undesired
results.
If you quote a numeric value, \f[I]jo\f[R] will make it a string.
Compare the following:
.IP
.EX
$ jo a=1.0
{\(dqa\(dq:1}
$ jo a=\(rs\(dq1.0\(rs\(dq
{\(dqa\(dq:\(dq1.0\(dq}
.EE
.PP
Omitting a closing bracket on a nested element causes a diagnostic
message to print, but the output contains garbage anyway.
This was designed thusly.
.SH RETURN CODES
\f[I]jo\f[R] exits with a code 0 on success and non\-zero on failure
after indicating what caused the failure.
.SH AVAILABILITY
\c
.UR http://github.com/jpmens/jo
.UE \c
.SH CREDITS
.IP \(bu 2
This program uses \f[CR]json.[ch]\f[R], by Joseph A. Adams.
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://stedolan.github.io/jq/
.UE \c
.IP \(bu 2
\c
.UR https://github.com/micha/jsawk
.UE \c
.IP \(bu 2
\c
.UR https://github.com/jtopjian/jsed
.UE \c
.IP \(bu 2
strtod(3)
.SH AUTHOR
Jan\-Piet Mens \c
.UR http://jpmens.net
.UE \c
